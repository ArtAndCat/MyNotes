# 内存模型
## 代码区
放程序代码的地方（二进制的（二进制是0和1））
共享 （可以打开多个程序但只占用同一个代码区，降低内存占用）
只读（防止篡改）

## 全局区
全局变量和静态变量。
常量区  字符串常量  其他常量
const 修饰的其他常量也在这里存放
## 栈区
编译器自动编译分配释放，存放函数的参数值，局部变量等所有的变量

## 堆区
由程序员分配和释放，若程序员不释放程序结束时由系统进行回收
https://b23.tv/fh9L5d3  *黑马p87*

## new操作符
new创建的数据,会返回数据对应的类型指针
语法：new 数据类型
例子：
```cpp
int* a(){
  int* p = new int(12); //在“堆区”创建一个int类型的变量
  return p;             //返回指针所指的堆区内存地址
}                       //函数a的生命周期结束，意味着函数内声明的变量什么的将会被系统回收（指针p将会被回收，但指针p指向的堆区内存的变量不会被回收）
//把下面的代码复制到main自行添加cout
  int* b = a();         //这个指针b将指向函数a返回的堆区内存地址。
  delete b;             //删除
```
### delete 数据类型 是清除
（delete清除的是内存空间,不是地址.内存已经释放(清除)完再次访问就会报错）
https://b23.tv/hMzR2pX  *黑马p88*
# 引用
## 基本使用
作用：给变量起别名
语法：数据类型&别名= 原名（数据类型和原来一致）
int a = 10; int &b = a;
## 引用注意事项
1. 引用必须初始化
2. 引用一旦初始化后,就不能改别的引用了
## 引用做函数参数
作用：函数传参时可以利用引用的技术让形参修饰实参
优点：可以简化指针修改实参
## 引用函数返回值
作用：引用可以作为函数返回值存在
注意：不能返回局部变量的引用
用法：如果函数做左值那必须返回回引用
int& aa= a;
## 引用的本质
本质是在c++内部实现一个指针常量
## 常量引用
作用：常量引用主要修饰形参防止误操作
函数形参列表中可以加const修饰形参
引用需要一个合法的内存空间
## 函数高级
#### 默认参数
```cpp
int name(int a = 0){
    return a;
}
int name(double a){    }

double name(){   }
```
#### 占位参数
(只写变量类型，不写名字。支持默认参数。)铺垫,知道有这个技术就可以了。
#### 函数重载
1.同一作用域  2.函数名相同 3.参数类型/个数/顺序不同
注意事项：引用作为承载的条件   函数重载碰到默认参数。
const int....     
# 类和对象
## 封装20
class //类定义
格式
```
class className{       // 这是个类
public:
    int number = 0;    //类 属性
    void helloWorld(){ // 行为
        std::cout << "你觉得我会输出helloWorld？" << number << std::endl;
    }    
};

```

## 访问权限21
1. public 公共权限 类内类外可以访问
2. protected 保护权限 类内可以访问类外不可 (儿子可访问父亲中的保护内容)
3. private 私有权限 类内可以访问类外不可
 (儿子不可访问父亲中私有内容)

## struct和class区别22
struct 默认权限为 公共
class 默认权限为 私有
&# 构造函数
## 构造与析构函数23
### 构造函数语法:类名(){} 
//就是class后的名字
1. 构造函数,没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数,因此可以发生重载
4. 程序在调用对象的时候会自动调用构造函数,无需手动而且只会一次

### 析构函数语法:~类名(){} 
//class后的名字
1. 析构函数,没有返回值也不写void
2. 函数名称与类名相同,在名称前加符号
3. 析构函数不可加参数,因此不可发生重载
4. 承租在对象销毁前会自动调用析构,无需手动调用,而且只会调用一次

## 函数分类以及调用  24
有两种分类方式：
按照参数分为：有参构造和无参构造
按照类型分为：普通构造和拷贝构造
**默认情况下c++编译器至少会给一个类添加个函数**
1. 默认构造函数(无参,函数体空)
2. 默认析构函数(无参,函数体空)
3. 默认拷贝构造函数,对属性进行值拷贝
**析构函数调用**
1. 如果用户定义有参构造函数c++不再提供无参构造,但会提供拷贝构造
2. 如果用户定义拷贝构造函数,c++不会再提供别的函数

## 拷贝构造函数调用时机 25
1. 使用一个已经创建完毕的对象来初始化一个新的对象
2. 值传递的方式给函数参数传值
    （返回类型 函数名(类名 对象){...}）
    会再次 类名 对象 = 对象....（会导致两次构造函数）
3. 值方式返回局部对象
（类名 函数名();）
## 构造函数调用规则  26
默认情况下，c++编译器至少给一个类添加三个函数
1. 默认构造函数无参。函数体为空
2. 默认析构函数无参。函数题为空
3. 默认拷贝构造函数。对属性进行直拷贝
构造函数调用规则
1. 如果用户定义有参构造函数(c++不再提供默认无参构造，但是会提供拷贝构造)
2. 如果用户定义拷贝构造函数c++，不会再提供其他各的函数
## 深拷贝与浅拷贝  27
浅拷贝：简单的赋值拷贝操作
深拷贝：在堆区重新申请空间,进行拷贝操作

![[Screenshot_20240314_223106 1.jpg]]

## 初始化列表28
作用:c++提供初始化列表,用来初始化属性
语法:构造函数();属性1(值1),属性2(值2)...{}
## 类对象作为类成员29
类中的成员可以作为另一个类的对象
，将这种成员称为对象成员
```cpp
//手机类
class mphone
{
public:
    phone(string pname)
    {
        mpname = pname;
    }
    string mpname;//手机品牌
}
//人类
class lei
{
	public:
	person(string name,string pname):mname(name),mphone(pname)
	{
	    cout
	}
	string mname;
	phone mphone;
}
```
就是说lei mphone可以在lei 作为另一个类对象
## 静态成员30&31
静态成员就是在成员的变量和成员函数前加上关键static称为静态成员
### 静态成员变量(属于静态成员的一课)
静态成员变量
1. 所有对象共享同一份数据
2. 在编译阶段分配内存 （所在区：全局区）
3. 类内声明，类外初始化
4. (静态成员也有权限)
```cpp
class lei
{
static int a;
}
int lei::a = 10;
1通过对象进行访问
lei A;
void perform()
{
cout << A.a << endl;
class A{}
class B
{
A b;//B类中有A作为成员 A为对象成员
}
```
## 成员变量和成员函数是分开存储的32
```cpp
class lei 
{
public:

int a; //非静态成员变量 属于类的对象上
static int b; //静态成员变量 不属于类对象上
void dd(){} // 非静态成员函数 不属于类对象上
static void dd2(){} //静态成员函数不属于类对象上
};
```
(
1. 空对象占用空间1
2. c++编译器会给每个对象分配一个字节空间。是为了区分对象占内存的位置
3. 每个空对象也应该有一个独一无二的内存地址
)



















## this指针33
this指针是隐含每个非静态成员函数内的一中指针
this指针不需要定义,直接使用
用途：
当形参和成员变量同名时,可以用this指针来区分
在类的非静态成员函数中返回对象本身,可使用return *this
用法：  this->变量;
## 空指针访问成员函数34
空指针也可以调用成员函数的,但是也要注意有没有用到this指针
**如果用到this指针**,**需要加判断保证代码的健壮性**
## const修饰成员函数o35
常函数：
常函数成员函数加const后我们成这个函数为常函数
常函数内不可以修改成员属性
成员属性声明时加关键字mutable后在常函数中依然可以回复修改
常对象：
声明对象前加const称该对象为常对象
常对象只能调用常函数