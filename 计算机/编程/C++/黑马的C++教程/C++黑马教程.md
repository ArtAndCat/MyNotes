#编程  #大 #视频笔记 #C 







# 第一个大部分
###### 三目运算符
```cpp
a < b ? 真时返回:假时返回;
```

###### switch选择
```cpp
switch(？){
    case 1  :
       statement(s);
       break; // 可选
    case 2  :
       statement(s);
       break; // 可选
       
    // 您可以有任意数量的 case 语句
    default : // 可选的
       statement(s);
}
```
###### 进入下一循环：
```cpp
continue;
```
###### 跳出：
```cpp
break;
```
###### 跳转：
```cpp
goto 名字;

名字;
```
# 第二个大部分

### 1~4   内存四区域============
<hr />

[代码区](代码区.md)：函数体的二进制编码...               运行前
[全局区](全局区.md)：全局变量，静态变量及常量...    运行前
[栈区](栈区.md)：局部变量函数体的参数值...           运行后
[堆区](堆区.md)：程序员来管理...                             运行后

### 5  new运算符==============
<hr />

  使用new操作符在堆区开辟数据。
  然后用delete来删除数据
#####  例子：
```cpp
int* a(){
	int* p = new int(12); //在“堆区”创建一个int类型的变量
	return p;             //返回指针所指的堆区内存地址
}                       //函数a的生命周期结束，意味着函数内声明的变量什么的将会被系统回收（指针p将会被回收，但指针p指向的堆区内存的变量不会被回收）
//把下面的代码复制到main自行添加cout
	int* b = a();         //这个指针b将指向函数a返回的堆区内存地址。
	delete b;             //删除
```


### 6~11  引用================
<hr />

#### 用法：
如果函数做左值那必须返回回引用 `int& aa = a;`
#### 引用注意事项
1. 引用必须初始化
2. 初始化后,不能改别的引用
#### 引用做函数参数
作用：函数传参时可以利用引用的技术让形参修饰实参
优点：可以简化指针修改实参
#### 引用函数返回值
作用：引用可以作为函数返回值存在
注意：不能返回局部变量的引用
#### 引用的本质
本质是在c++内部实现一个指针常量

### 12~15 函数高级============
<hr />

#### 默认参数
```cpp
int name(int a = 0){
    return a;
}
int name(double a){    }

double name(){   }
```
#### 占位参数
(只写变量类型，不写名字。支持默认参数。)铺垫,知道有这个技术就可以了。
#### 函数重载
1.同一作用域  2.函数名相同 3.参数类型/个数/顺序不同
注意事项：引用作为承载的条件   函数重载碰到默认参数。
const int....     
### 16~22 类和对象 封装==========
<hr />

#### 封装 16

^f8c848



```cpp
class className{       // 这是个类
public:
    int number = 0;    //类 属性
    void helloWorld(){ // 行为
	    std::cout << "你觉得我会输出helloWorld？" << number << std::endl;
    }    
};

int main(){
    className targetName;    //实例化（通过类创建对象的）
    
    targetName.number++;     //调用对象的变量
    targetName.helloWorld(); //调用对象的函数
    //剩下的懒得写了
}
```
#### 封装 案例 学生 17    懒得写了
#### 访问权限 18

三种：
公共  类外也可以访问
```cpp
public:
```
保护  子级可以访问 
```cpp
protected:
```
私有  仅内部可访问 子级也不行
```cpp
private:
```
例子：
```cpp
class className{
private:
    int a;//变量和行为.....
public:
	//变量和行为.....
}
```
#### C++中class和struct(自定数据类型)的区别
默认的访问权限不一样  一个私有  一个公共
#### 成员属性设为私有  20
优点1: 将所有成员属性设为私有，可以自己控制读写权限。
优点2: 对于写权限，我们可以检测数据的有效性。
### 23~35类和对象 对象特性=========
____

#### 构造函数（初始化）和分析函数（删除） 23
###### 构造函数语法：在类名里面写：类名(){函数}
1. 没有返回值也不写void。
2. 函数名\=\=类名
3. 可以有参数，因此可以发生重载。
4. 程序调用对象时自动调用，无须手动调用，而且只会调用一次。
###### 析构函数语法：（只记录和“构造”的不同点。）

^c213a8
不允许有参数，前面加“~”
###### 使用方法：
```cpp
class abc {
	int a;
	abc(){//构造
		a = 1;
	}
	abc(int aa){
		a = aa;
	}
	abc(const abc &p){
		a = p.a;
	}
	~abc(){//删除
		
	}
}
```
#### 构造函数的分类以及调用  24

^52df4b

##### 两种分类
1. 按参数分:   有参构造和无参构造
2. 按类型分:   普通构造和拷贝构造
##### 三种调用
1. 括号法
```cpp
类名 对象名;   //无参构造函数（也叫默认构造函数，不要加括号！）
类名 对象名(变量);    //有参构造
类名(const 类名& p){   } //拷贝构造的声明方法
类名 对象名(对象名);    //拷贝构造
```
2. 显示法
```cpp
类名 对象名 = 类名(变量); //有参构造
类名 对象名 = 类名(对象名);//拷贝构造
类名(变量);//没有名的对象 会被立刻回收。
//（不要把变量名改成对象名编译器会把他当成对象的声明。）
```
3. 隐式转换法
```cpp
类名 对象名 = 10;    // 有参构造  这也行！？？
类名 对象名 = 对象名; // 拷贝构造  这也行！？？
```

#### 拷贝构造函数调用时机 25
1. 使用一个已经创建完毕的对象来初始化一个新的对象
2. 值传递的方式给函数参数传值
    （返回类型 函数名(类名 对象){...}）
    会再次 类名 对象 = 对象....（会导致两次构造函数）
3. 值方式返回局部对象
（类名 函数名();）
##### 

#### 构造函数调用规则 26
默认情况下，c++编译器至少给一个类添加三个函数
1. 默认构造函数无参。函数体为空
2. 默认析构函数无参。函数题为空
3. 默认拷贝构造函数。对属性进行直拷贝
构造函数调用规则
1. 如果用户定义有参构造函数(c++不再提供默认无参构造，但是会提供拷贝构造)
2. 如果用户定义拷贝构造函数c++，不会再提供其他各的函数
#### 深拷贝与浅拷贝  27
浅拷贝：简单的赋值拷贝操作
深拷贝：在堆区重新申请空间,进行拷贝操作
![[Screenshot_20240314_223106 1.jpg]]
使用new在堆区开辟空间，析构函数也有用了
析构函数中的东西
```cpp
if (堆区指针 != nullptr){
	delete 堆区指针;
	堆区指针 = nullptr;
}
```
但浅拷贝时两个对象都指向同一个堆区空间，==解析函数会重复释放导致非法操作==，所以需要自己写==拷贝构造函数==
#### 初始化列表  28
作用:c++提供初始化列表,用来初始化属性
```cpp
构造函数():属性1(值1),属性2(值2)...{....}
```
#### 类对象作为类成员29  （略）

#### 静态成员     30&31
静态成员就是在成员的变量和成员函数前加上关键static称为静态成员
静态成员变量
1. 共享同一份数据
2. 在编译阶段分配内存 （所在区：全局区）
3. 类内声明   内外初始化。   记得使用   ::
4. (静态成员也有权限)
###### 例子：
```cpp
#include <iostream>
using namespace std;

class MyClass {
public:
    static int count; // 静态成员变量
    
    MyClass() {
        count++; // 每次创建对象时，count加1
    }
};

int MyClass::count = 5; // 初始化静态成员变量count为0

int main() {
    MyClass obj1; // 创建一个MyClass对象，count加1
    MyClass obj2; // 创建另一个MyClass对象，count再加1
    
    cout << "obj1.count: " << obj1.count << endl; // 输出：obj1.count: 2
    cout << "obj2.count: " << obj2.count << endl; // 输出：obj2.count: 2
    return 0;
}
```
#### 成员变量和成员函数是分开存储的    32
```cpp
class lei 
{
public:
	int a;   //非静态成员变量 属于类的对象上
	static int b; //静态成员变量 不属于类对象上
	void dd(){} // 非静态成员函数 不属于类对象上
	static void dd2(){} //静态成员函数不属于类对象上
};
```
(
1. 空对象占用空间1
2. c++编译器会给每个对象分配一个字节空间。是为了区分对象占内存的位置
3. 每个空对象也应该有一个独一无二的内存地址
)

#### this指针    33
this指针是隐含每个非静态成员函数内的一中指针
this指针不需要定义,直接使用
用途：
当形参和成员变量同名时,可以用this指针来区分
在类的非静态成员函数中返回对象本身,可使用return \*this
```cpp
this->变量;
```
#### 空指针访问成员函数      34
空指针也可以调用成员函数的,但是也要注意有没有用到this指针
**如果用到this指针**,**需要加判断保证代码的健壮性**
#### const修饰成员函数    35
常函数：
```cpp
const 返回类型 函数名(...){....}
```
常函数内不可以修改成员属性
成员属性声明时加关键字mutable后在常函数中依然可以回复修改
常对象：
```cpp
const 类名 对象名
```
常对象只能调用常函数







### 36~38 类和对象 友元   friend======
____
#### 36 全局函数做友元 

```cpp
class l{
	friend 返回类型 aaa(参数);
	...
};
```
这样的话函数aaa就可以访问类l中的私有变量及函数
#### 37 类做友元

```cpp
friend class 类名;  // 这个要写在类里面！！
```
让一个类去访问另一个类的私有成员
###### 例子：
```cpp
class A{
	friend class B;//关键代码
	int a;
	A(){//构造函数
		a = 10;
	}
};

class B{
	void coutA(A *a){//传入类A类型的指针
		std::cout << a.a;//访问指针中的变量
	}
};
```
main中东西
```cpp
A a;
B b;
b.coutA(&a);
```
#### 38 成员函数做友元

```cpp
friend 函数返回类型 类名::函数名();
```
是的，没了。
#### 37 中的其他内容  在类外写成员函数与构造函数====
____
```cpp
类名::类名(){//构造函数
	...
}

返回类型 类名::函数名(){//成员函数（记得在类中声明）
	...
}
```
### 39~44 类和对象  运算符重载========
____
#### +操作
编译器提供了名字但没有提供实现方法
成员函数构造+
```cpp
返回类型（类） operator+ (类 &对象3){
	类 对象;
	对象.属性 = this->属性 + 对象3.属性
	...
	return 对象
}
```
全局函数构造+
```cpp
返回类型（类） operator+ (类 &对象2,类 &对象3){
	类 对象;
	对象.属性 = 对象2.属性 + 对象3.属性
	...
	return 对象
}
```
怎么使用
```cpp
//使用成员函数调用
类 对象1 = 对象2.operator+(对象3);
//使用全局函数调用
类 对象1 = operator+(对象2，对象3);
//上面两个都可以简写为
类 对象1 = 对象2 + 对象3;
```

###### 讲解
#### <<操作 （左移）
编译器提供了名字但没有提供实现方法
##### 成员函数构造<<
```cpp
//这样写的话简化版本就变成了“ 对象 << cout ”了  不是我们想要的
//void operator<< (cout){  
//}
```
##### 全局函数构造<<
```cpp
void ​operator<< (ostream &cout,类 &对象2){
	 cout << 对象2.属性1 << 对象2.属性2  ....
}
```
ostream &cout是什么？             7：27
cout是 “类”ostream 中的“对象” o表示输出 
为什么使用&？
这个对象全局只能有这一个（把&当做指向全局唯一的cout的指针）
##### 怎么使用
```cpp
//使用成员函数调用
//？
//使用全局函数调用
operator<<(cout，对象3);
//可以简写为
cout << 对象3;
```
（如果把cout换成读写文件的那个对象.........）
但如果
```cpp
cout << 对象3 <<...
```
编译器就会报错，怎么办呢？（链式编程）
```cpp
ostream & ​operator<< (ostream &名字,类 &对象2){
	 名字 << 对象2.属性1 << 对象2.属性2  ....
	 return 名字;
}
```
#### ++操作（自增）
##### 前置递增：
```cpp
类名& ​operator++ (){
	 //这里写“参数操作” 如 智商++...
	 return *this;//返回本身
}
```
为什么用&（11：25左右）
返回引用是为了一直对同一个值进行操作
##### 后置递增：
```cpp
类名 ​operator++ (int){
	 // 先记录当时结果到 what
	 类名 what = *this
	 // 后递增
	 //参数操作
	 return what;//返回 what
}
```
int 代表“占位参数”  用于区分前置和后置（编译器只认int）
为什么这里不返回引用？what是局部变量  然后你懂的（非法操作）
课后作业：--
#### =赋值 
编译器提供的=是浅拷贝
浅拷贝 + new堆区.. = 堆区重复释放->程序崩溃([[#深拷贝与浅拷贝 27]])
```cpp
void ​operator= (类名 & a){
	 //先delete 和 nullptr
	 //然后让指针指向新的堆区数据...
	 指针 = new(*a.指针)
}
```
但如果使用a=b=c（链式编程）就会报错，解决方法：
void改成类名\*
加 return \*this
#### <>=..运算符重载  43
```cpp
bool ​​operator== (类名 &a){
	 if (条件)return 1;//如：this->年龄 == a.年龄
	 return 0;//返回本身
}
```



#### 函数调用运算符重载 44（仿函数  STL和多线程会用到）
```cpp
返回类型 ​​operator()(参数){
	....
}
```
“像”调用函数一样去调用即可  也因为“像”所以叫“仿函数”
同时它有着像类一样存储数据的功能.. 比如你可以整个这个函数的调用次数统计...
7：30  匿名函数对象：
```cpp
类名()(参数...)
```

### 45~52 继承=================
----
[[C++面向对象 封装  继承  多态#^baddb0]]  基础语法  45
[[C++面向对象 封装  继承  多态#^d643b9]]  继承方式  46
[[C++面向对象 封装  继承  多态#^397f1d]]   私有继承是否占空间？47
#### 父类和子类构造和析构顺序 48     略   用脚都能想的出来。
#### 同名成员处理方式  49    覆盖    用脚都能想的出来。
#### 怎么访问父类的东西？49  `对象.类::成员`
注意：如子类出现父类同名函数父类所有函数将被隐藏。49
#### 静态成员函数只能访问静态成员变量 50
```cpp
对象.类名::成员//对象的父类的成员变量
类名::类名::成员//直接用类访问
```
#### 多继承语法：[[C++面向对象 封装  继承  多态#继承]]  51
#### 菱形继承问题 [[C++面向对象 封装  继承  多态#继承]] 52
### 53~60 多态==============
---


这里好TM抽象！！我得梳理一下...

可以将子类的函数覆盖到父类中以进行调用
然后呢，可以....算了直接看代码吧...
```cpp
class 类1 {
    void 函数1
};
class 类2 :public 类1 {
    void 函数1
};

void 函数(类1 对象){//注意这里是 类1
    对象.函数1
}

int main(){
    类2 对象;
    函数(对象);//这里传入的是用 类2 创建的对象
}
//这个代码不仅可以运行它还可以正常调用类2的函数。
```

#### [[C++面向对象 封装  继承  多态#多态]]  53~54
#### 案例1计算机类    55
##### 框架：
```cpp
#include<iostream>
#include<string>
using namespace std;

//标记1

int main(){
	//标记2
	return 0;
}
```
##### 普通写法：
如果想扩展新的功能，需要修改源码。
在真实开发中提倡开闭原则   对扩展进行开放，对修改进行关闭。
标记1
```cpp
class Calculator{
public:
	int num_1;
	int num_2;
	
	int gitResult (string oper){
		if (oper == '+'){
			return num_1 + num_2;
		}else if(oper == '-'){
			return num_1 - num_2;
		}//......
	}
};
```
标记2
```cpp
Calculator c;
c.num_1 = 5;
c.num_2 = 10;
cout << c.num_1 << '+' << c.num_2 << '=' << c.gitResult('+') << endl;
```

##### 多态实现
代码量大了，但是组织结构清晰。
标记1
```cpp
class AbstractCalculator{
public:
	int num_1;
	int num_2;
	virtual int getResult(){
		return 0;
	}
};
//往“抽象计算器”内添加“加法计算器这个类”
class AddCalculator ：public AbstractCalculator{
	virtual int getResult(){//前面的virtual可带可不带
		return num_1 + num_2;
	}
};
//往“抽象计算器”内添加“减法计算器这个类”
class SubCalculator ：public AbstractCalculator{
	virtual int getResult(){//前面的virtual可带可不带
		return num_1 - num_2;
	}
};
//....
```
标记2
```cpp
AbstractCalculator * abc = new AddCalculator;//?????
// ↑ 父类指针指向子类对象，这里指向的是加法函数。
abc->num_1 = 5;
abc->num_2 = 10;

cout << abc->num_1 << '+' << abc->num_2 << '=' << abc->getResult() << endl;

delete abc;

abc = new SubCalculator;//父类指针指向子类对象，这里指向的是减法函数。
//...
```

#### 纯虚函数和抽象类    56
在父类虚函数没有用的时候就可以把虚函数改为纯虚函数。
语法：
```cpp
virtual 返回类型 函数名 (参数) = 0;
```
只要类中有了纯虚函数时这个类也被称为==抽象类==。
特点：
- ==抽象类==不能创建对象（补充但他可以指向一个对象？）
- 子类必须重写==抽象类==中的纯虚函数，否则也会被继承为==抽象类==。
#### 案例2   制作饮品  57
```cpp
//制作饮品 是一个抽象类  内包括纯虚函数：煮 搅...
//制作咖啡 继承 制作饮品
//制作茶叶 继承 制作饮品
void 工作(制作饮品 * abc){
	abc->函数();
	delete abc;
}

工作(new 制作咖啡) // 有点儿眼熟....占位参数???
```
#### 纯析构和纯虚析构  58
多态使用时，如果子类有数据开辟到了堆区，那么父类指针在释放时无法调用到子类的析构代码。
解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**
虚析构语法
```cpp
virtual ~类名(){}
```
纯虚析构语法
```cpp
virtual ~类名() = 0;
```

区别：如果是纯虚析构，该类属于抽象类，无法实例化对象。
#### 案例 59~60




### 61~64 文件操作=============
----
#### [[C++文件读写]] 

## 职工管理系统
## 第三个大部分
### 1~18模板 [[C++STL库 （标准模板库）]]

#### 概念介绍  1
stl库和函数模板什么的...
#### 函数模板基本语法-函数模板 2

使用时再确定内部的类型（和vector什么的很像，<>里放数据类型）
主要代码
```cpp
template<typename 名称>// typename可以替换为class
返回类型 函数名(.....){....}
```
###### 例子
```cpp
//声明
template<typename Cat>//提前声明防止报错
void mySwap(Cat &a,Cat &b){
	Cat c = a;
	a = b;
	b = c;
}
//使用  放置到main中
mySwap(a,b);//自动推倒
//方法2  显示指定类型
mySwap<int>(a,b);
```
#### 函数模板-注意事项  3
- 必须推导出一致的数据类型
- 必须确定出 ___ 的数据类型


#### 函数模板-案例 4
#### 普通函数与函数模板的区别  5
1. 普通函数可以隐式转换   声明两个 int 传入 int 和 char 可运行
2. 使用函数模板自动推倒时会报错
3. 使用函数模板但显示指定类型时可以发生隐式转换

#### 普通函数与模板函数的调用规则  6

1. 都可调用时优先普通
2. 通过空模板参数列表强制调用
`函数名<>(参数);`
3. 可以发送重载
4. 如果普通函数模板匹配更好就优先调用普通

#### 模板的局限性  7
如果给他个自定义数据类型，程序不会有语法问题，但运行后程序就懵了，所以需要用到：
```cpp
template<> 返回类型 函数名(自定义数据类型 名称...){
	//...
}
```
#### 函数模板基本语法-类模板  8

```cpp
template<class 名称A,class 名称B>// typename可以替换为class
class 类名{
public:
	类名(名称A aa,名称B bb){
		this->名字 = aa;
		this->名称 = bb;
	}
	名称A 名字;
	名称B 名称;
	//....
};
// 使用方法
类名<数据类型,数据类型> 对象名(参数,参数);
```

#### 函数模板基本语法-类模板  9
1. 不能自动推倒
2. 可以有默认参数（class 名称B = int  默认int类型）

#### 类模板中成员函数创建时机  10
1. 子函数在一开始不会创建仅在调用时才会创建
#### 类模板对象做函数参数  11
方法1

```cpp
void 函数名(类名<数据类型,数据类型> &p){
	// ...
}
类名<数据类型, 数据类型> 对象名(参数,参数);

函数名(对象名);
```
方法2
```cpp
template<class T1,class T2>
void 函数名(类名<T1,T2> &p){
	// ...
}
类名<数据类型, 数据类型> 对象名(参数,参数);

函数名(对象名);
```
方法3
```cpp
template<class T>
void 函数名(T &p){
	// ...
}
类名<数据类型, 数据类型> 对象名(参数,参数);

函数名(对象名);
```

#### 类模板与继承  12
1. 必须指定类型，否则编译器不知道怎么指定内存
```cpp
class 类名2 : public 类名<数据类型>{
```
2. 子类也需变为类模板
```cpp
template<class C,class D>// typename可以替换为class
class 类名2 : public 类名<C,D>{
```

#### 类模板类外实现  13
```cpp
template<class C,class D>// typename可以替换为class
类名<C,D>::对象名(C 变量名 ,D 变量名){
```
#### 类模板多文件编程  14
把.h文件改为.cpp文件即可（比较乱）
正常情况：
主文件：
  .h文件（声明）
.h文件中：
.cpp文件中：
  .h文件（声明）
  实现

对于这种情况情况：
主文件：
  .cpp文件（.h文件（声明）与实现）
.h文件中：
   声明
.cpp文件中：
   .h文件（声明）
   实现
#### 类模板与友元  15

类内实现没啥区别
```cpp
friend 返回类型 函数名(数据类型 名字){}
```
##### 类外实现：
方法1
```cpp
// 提前让编译器知道这个函数...等等...这么简单？？

```

```cpp
friend 返回类型 函数名<>(数据类型 名字);
```
### 类模板案例 16~18

### [[C++STL库 （标准模板库）]]

#### [[string]]   23~30

#### [[Vector容器]]
## 演讲比赛流程管理


## 机房预约系统












