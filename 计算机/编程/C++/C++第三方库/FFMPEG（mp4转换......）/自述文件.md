# ffmpeg-cpp
A clean C++ wrapper around the ffmpeg libraries which can be used in any C++ project or C# project (with DllImport or CLR). Makes the most commonly used functionality of FFmpeg easily available for any C++ projects with an easy-to-use interface. The full power of FFmpeg compacted in 10 lines of C++ code: if this sounds useful to you, read on!

围绕ffmpeg库的干净的C++包装器，可用于任何C++项目或C#项目（使用DllImport或CLR）。通过一个易于使用的界面，使FFmpeg最常用的功能可轻松用于任何C++项目。FFmpeg的全部功能压缩在10行C++代码中:如果这听起来对您有用，请继续阅读
# Installation

## Windows

1. Clone the repository克隆存储库
2. Download a build of FFmpeg from https://ffmpeg.zeranoe.com/builds/. The project was last tested with **4.1**. You will need both the dev version (for .h and .lib files) and the shared version (for .dll). Extract all of them into the ffmpeg directory in the repository. there are more instructions on how to extract them properly in the ffmpeg/readme.txt file.
3. Open the Visual Studio solution in the source directory.在源目录中打开Visual Studio解决方案。
4. 建造一切

This will build a .lib file that you can use in your own C++ projects. It will also generate an include-folder in the repo root that you can add to your include filders in your own project.
这将构建一个您可以在自己的C++项目中使用的.lib文件。同时，它还会在仓库根目录下生成一个include文件夹，您可以将其添加到自己项目中的包含文件夹中。
## Linux

Currently, only a Windows environment with Visual Studio is supported. This is simply because I do not have experience with cmake and Linux-projects, since the project itself is fully platform-independent. If anyone is willing to help me out with configuring cmake, please get in touch!

# Usage

There are multiple demo projects included in the solution. Check out the demo-project for a thorough exploration of the features (demuxing, decoding, filtering, encoding, muxing) or one of the other examples for a simpler example to follow.

There is also a .NET Core compatible simplified interface included so that you can embed this project in your .NET Core projects.

## C++

To give you an idea, this code will load a video stream from a container, filter it, and write it back out to another container:
为了给你一个思路，这段代码将从一个容器加载一个视频流，对其进行过滤，并将其写回另一个容器:

```C++
// 创建一个muxer，用于将视频输出为MP4格式。
Muxer* muxer = new Muxer("filtered_video.mp4");

// 创建一个MPEG2编码器，用于对原始数据进行编码。
VideoCodec* codec = new VideoCodec(AV_CODEC_ID_MPEG2VIDEO);

// 创建一个视频编码器，使用上述指定的编解码器对原始音频数据进行编码。
// 将其与muxer关联，以便编码后的数据会被写入文件。
VideoEncoder* encoder = new VideoEncoder(codec, muxer);

// 创建一个视频滤镜并对视频数据执行一些有趣的操作。
Filter* filter = new Filter("scale=640:150,transpose=cclock,vignette", encoder);

// 加载一个媒体容器。从中选取最佳的视频流并发送给滤镜。
Demuxer* demuxer = new Demuxer("big_buck_bunny.mp4");
demuxer->DecodeBestVideoStream(filter);

// 准备输出管道。
// 这将解码一小部分帧，以便管道可以自我配置。
demuxer->PreparePipeline();

// 将剩余的所有帧推进处理。
while (!demuxer->IsDone())
{
    demuxer->Step();
}

// 通过关闭muxer将所有内容保存到磁盘。
muxer->Close();
```

If you use the included simple-interface library, which only supports a subset of the full library, using ffmpeg-cpp becomes even easier:
如果您使用附带的简单接口库（仅支持完整库的子集），使用ffmpeg-cpp将变得更加容易:

```cpp
#include "SimpleInterface.h"

int main()
{
	void* handle = ffmpegCppCreate("out.mp4");
	ffmpegCppAddVideoStream(handle, "samples/big_buck_bunny.mp4");
	ffmpegCppAddVideoFilter(handle, "transpose=cclock[middle];[middle]vignette");
	ffmpegCppAddAudioStream(handle, "samples/big_buck_bunny.mp4");
	ffmpegCppGenerate(handle);
	ffmpegCppClose(handle);
}
```

## C\#

The simple-interface is made in such a way that it can easily be called using [DllImport] from any C# project:

```cs
	public class Example
	{

		public Example()
		{
			try
			{
				string inFileName = "in.mp4";
				string outFileName = "out.mp4";
				IntPtr handle = ffmpegCppCreate(outFileName); CheckError(handle);
				ffmpegCppAddVideoStream(handle, inFileName); CheckError(handle);
				ffmpegCppAddAudioStream(handle, inFileName); CheckError(handle);
				ffmpegCppAddVideoFilter(handle, "crop=1080:1920:740:0[middle];[middle]transpose=3"); CheckError(handle);
				ffmpegCppGenerate(handle); CheckError(handle);
				ffmpegCppClose(handle);
			}
			catch (InvalidOperationException e)
			{
				Console.WriteLine("ERROR: " + e.Message);
			}
		}

		private void CheckError(IntPtr handle)
		{
			if (ffmpegCppIsError(handle))
			{
				IntPtr errorPtr = ffmpegCppGetError(handle);
				string error = Marshal.PtrToStringAnsi(errorPtr);
				throw new InvalidOperationException(error);
			}
		}

		[DllImport("simple_interface.dll", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr ffmpegCppCreate(string outFileName);

		[DllImport("simple_interface.dll", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ffmpegCppAddVideoStream(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string inFileName);

		[DllImport("simple_interface.dll", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ffmpegCppAddAudioStream(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string inFileName);

		[DllImport("simple_interface.dll", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ffmpegCppAddVideoFilter(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string filterString);

		[DllImport("simple_interface.dll", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ffmpegCppAddAudioFilter(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string filterString);

		[DllImport("simple_interface.dll", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ffmpegCppGenerate(IntPtr handle);

		[DllImport("simple_interface.dll", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool ffmpegCppIsError(IntPtr handle);

		[DllImport("simple_interface.dll", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr ffmpegCppGetError(IntPtr handle);

		[DllImport("simple_interface.dll", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ffmpegCppClose(IntPtr handle);
	}
```

If you want to use ffmpeg-cpp in a C# project, you can easily do so by making your own C-wrapper around the 

# Why?
#### a
I developed this project to be able to to integrate FFmpeg into our program without having to call the executable to do an operation. This is important because starting up an external executable tends to be blocked by antivirus software and can cause issues with users. It has been tested for the most common functionality, and some of the examples from https://github.com/FFmpeg/FFmpeg/tree/master/doc/examples are mirrored in the project as well.
#### 中
我开发这个项目是为了能够将FFmpeg集成到我们的程序中，而不必调用可执行文件来执行操作。这一点很重要，因为启动外部可执行文件往往会被防病毒软件阻止，并可能给用户带来问题。它已经过最常见功能的测试，https://github.com/FFmpeg/FFmpeg/tree/master/doc/examples的一些例子也反映在该项目中。
# Roadmap  路线图

- Add Linux/Mac build support添加Linux/Mac构建支持
- Adding proper unit tests添加适当的单元测试
- Testing with more codecs, containers使用更多编解码器、容器进行测试

# License 许可证

This library is licensed under LGPL (https://en.wikipedia.org/wiki/GNU_Lesser_General_Public_License).

Please note though that FFmpeg, which you will need to build this library, is not. Depending on how you build it, it is either LGPL or GPL. So if you use the GPL-version of FFmpeg in your project, this library will be GPL too.
#### 中
但是请注意，构建这个库所需的FFmpeg不是。取决于你如何构建它，它要么是LGPL要么是GPL。所以如果你在你的项目中使用GPL版本的FFmpeg，这个库也将是GPL的。